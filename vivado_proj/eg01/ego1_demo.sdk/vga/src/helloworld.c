/******************************************************************************
*
* Copyright (C) 2009 - 2014 Xilinx, Inc.  All rights reserved.
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* Use of the Software is limited solely to applications:
* (a) running on a Xilinx device, or
* (b) that interact with a Xilinx device through a bus or interconnect.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
* XILINX  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
* OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
* SOFTWARE.
*
* Except as contained in this notice, the name of the Xilinx shall not be used
* in advertising or otherwise to promote the sale, use or other dealings in
* this Software without prior written authorization from Xilinx.
*
******************************************************************************/

/*
 * helloworld.c: simple test application
 *
 * This application configures UART 16550 to baud rate 9600.
 * PS7 UART (Zynq) is not initialized by this application, since
 * bootrom/bsp configures it to baud rate 115200
 *
 * ------------------------------------------------
 * | UART TYPE   BAUD RATE                        |
 * ------------------------------------------------
 *   uartns550   9600
 *   uartlite    Configurable only in HW design
 *   ps7_uart    115200 (configured by bootrom/bsp)
 */
#include"math.h"
#include <stdio.h>
#include "platform.h"
#include "xsysmon.h"
#include "xparameters.h"
#include "xil_printf.h"
#include"xstatus.h"
#include"xintc.h"
#include"xil_exception.h"
#include"xbasic_types.h"
#include"xgpio.h"
#define SYSMON_DEVICE_ID XPAR_XADC_WIZ_0_DEVICE_ID
#define XSysMon_RawToExtVoltage(AdcData)((((float)(AdcData))*(1.0f))/65536.0f)
#define VGA XPAR_SDK_VGA4_DIS_INCLUDED_0_S00_AXI_BASEADDR
#define WaveUp XPAR_SDK_VGA4_DIS_INCLUDED_0_S00_AXI_BASEADDR+12
#define WaveDown XPAR_SDK_VGA4_DIS_INCLUDED_0_S00_AXI_BASEADDR+16
#define Frequency XPAR_SDK_VGA4_DIS_INCLUDED_0_S00_AXI_BASEADDR+20
#define Vpp XPAR_SDK_VGA4_DIS_INCLUDED_0_S00_AXI_BASEADDR+24
#define Vmax XPAR_SDK_VGA4_DIS_INCLUDED_0_S00_AXI_BASEADDR+28
#define Vmin XPAR_SDK_VGA4_DIS_INCLUDED_0_S00_AXI_BASEADDR+32
/*unsigned char SinWaveTab[800]=
{
		0x80,0x83,0x86,0x89,0x8C,0x8F,0x92,0x95,0x98,0x9B,0x9E,0xA2,0xA5,0xA7,0xAA,0xAD,0xB0,0xB3,0xB6,0xB9,0xBC,0xBE,0xC1,0xC4,0xC6,0xC9,0xCB,0xCE,0xD0,0xD3,0xD5,0xD7,
		0xDA,0xDC,0xDE,0xE0,0xE2,0xE4,0xE6,0xE8,0xEA,0xEB,0xED,0xEE,0xF0,0xF1,0xF3,0xF4,0xF5,0xF6,0xF8,0xF9,0xFA,0xFA,0xFB,0xFC,0xFD,0xFD,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFD,0xFD,0xFC,0xFB,0xFA,0xFA,0xF9,0xF8,0xF6,0xF5,0xF4,0xF3,0xF1,0xF0,0xEE,0xED,0xEB,0xEA,0xE8,0xE6,0xE4,0xE2,0xE0,0xDE,0xDC,
		0xDA,0xD7,0xD5,0xD3,0xD0,0xCE,0xCB,0xC9,0xC6,0xC4,0xC1,0xBE,0xBC,0xB9,0xB6,0xB3,0xB0,0xAD,0xAA,0xA7,0xA5,0xA2,0x9E,0x9B,0x98,0x95,0x92,0x8F,0x8C,0x89,0x86,0x83,
		0x7F,0x7C,0x79,0x76,0x73,0x70,0x6D,0x6A,0x67,0x64,0x61,0x5D,0x5A,0x58,0x55,0x52,0x4F,0x4C,0x49,0x46,0x43,0x41,0x3E,0x3B,0x39,0x36,0x34,0x31,0x2F,0x2C,0x2A,0x28,
		0x25,0x23,0x21,0x1F,0x1D,0x1B,0x19,0x17,0x15,0x14,0x12,0x11,0x0F,0x0E,0x0C,0x0B,0x0A,0x09,0x07,0x06,0x05,0x05,0x04,0x03,0x02,0x02,0x01,0x01,0x01,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x03,0x04,0x05,0x05,0x06,0x07,0x09,0x0A,0x0B,0x0C,0x0E,0x0F,0x11,0x12,0x14,0x15,0x17,0x19,0x1B,0x1D,0x1F,0x21,0x23,
		0x25,0x28,0x2A,0x2C,0x2F,0x31,0x34,0x36,0x39,0x3B,0x3E,0x41,0x43,0x46,0x49,0x4C,0x4F,0x52,0x55,0x58,0x5A,0x5D,0x61,0x64,0x67,0x6A,0x6D,0x70,0x73,0x76,0x79,0x7C,
		0x80,0x83,0x86,0x89,0x8C,0x8F,0x92,0x95,0x98,0x9B,0x9E,0xA2,0xA5,0xA7,0xAA,0xAD,0xB0,0xB3,0xB6,0xB9,0xBC,0xBE,0xC1,0xC4,0xC6,0xC9,0xCB,0xCE,0xD0,0xD3,0xD5,0xD7,
		0xDA,0xDC,0xDE,0xE0,0xE2,0xE4,0xE6,0xE8,0xEA,0xEB,0xED,0xEE,0xF0,0xF1,0xF3,0xF4,0xF5,0xF6,0xF8,0xF9,0xFA,0xFA,0xFB,0xFC,0xFD,0xFD,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFD,0xFD,0xFC,0xFB,0xFA,0xFA,0xF9,0xF8,0xF6,0xF5,0xF4,0xF3,0xF1,0xF0,0xEE,0xED,0xEB,0xEA,0xE8,0xE6,0xE4,0xE2,0xE0,0xDE,0xDC,
		0xDA,0xD7,0xD5,0xD3,0xD0,0xCE,0xCB,0xC9,0xC6,0xC4,0xC1,0xBE,0xBC,0xB9,0xB6,0xB3,0xB0,0xAD,0xAA,0xA7,0xA5,0xA2,0x9E,0x9B,0x98,0x95,0x92,0x8F,0x8C,0x89,0x86,0x83,
		0x7F,0x7C,0x79,0x76,0x73,0x70,0x6D,0x6A,0x67,0x64,0x61,0x5D,0x5A,0x58,0x55,0x52,0x4F,0x4C,0x49,0x46,0x43,0x41,0x3E,0x3B,0x39,0x36,0x34,0x31,0x2F,0x2C,0x2A,0x28,
		0x25,0x23,0x21,0x1F,0x1D,0x1B,0x19,0x17,0x15,0x14,0x12,0x11,0x0F,0x0E,0x0C,0x0B,0x0A,0x09,0x07,0x06,0x05,0x05,0x04,0x03,0x02,0x02,0x01,0x01,0x01,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x03,0x04,0x05,0x05,0x06,0x07,0x09,0x0A,0x0B,0x0C,0x0E,0x0F,0x11,0x12,0x14,0x15,0x17,0x19,0x1B,0x1D,0x1F,0x21,0x23,
		0x25,0x28,0x2A,0x2C,0x2F,0x31,0x34,0x36,0x39,0x3B,0x3E,0x41,0x43,0x46,0x49,0x4C,0x4F,0x52,0x55,0x58,0x5A,0x5D,0x61,0x64,0x67,0x6A,0x6D,0x70,0x73,0x76,0x79,0x7C,
		0x80,0x83,0x86,0x89,0x8C,0x8F,0x92,0x95,0x98,0x9B,0x9E,0xA2,0xA5,0xA7,0xAA,0xAD,0xB0,0xB3,0xB6,0xB9,0xBC,0xBE,0xC1,0xC4,0xC6,0xC9,0xCB,0xCE,0xD0,0xD3,0xD5,0xD7,
		0xDA,0xDC,0xDE,0xE0,0xE2,0xE4,0xE6,0xE8,0xEA,0xEB,0xED,0xEE,0xF0,0xF1,0xF3,0xF4,0xF5,0xF6,0xF8,0xF9,0xFA,0xFA,0xFB,0xFC,0xFD,0xFD,0xFE,0xFE,0xFE,0xFF,0xFF,0xFF,
		0xFF,0xFF,0xFF,0xFF,0xFE,0xFE,0xFE,0xFD,0xFD,0xFC,0xFB,0xFA,0xFA,0xF9,0xF8,0xF6,0xF5,0xF4,0xF3,0xF1,0xF0,0xEE,0xED,0xEB,0xEA,0xE8,0xE6,0xE4,0xE2,0xE0,0xDE,0xDC,
		0xDA,0xD7,0xD5,0xD3,0xD0,0xCE,0xCB,0xC9,0xC6,0xC4,0xC1,0xBE,0xBC,0xB9,0xB6,0xB3,0xB0,0xAD,0xAA,0xA7,0xA5,0xA2,0x9E,0x9B,0x98,0x95,0x92,0x8F,0x8C,0x89,0x86,0x83,
	    0x7F,0x7C,0x79,0x76,0x73,0x70,0x6D,0x6A,0x67,0x64,0x61,0x5D,0x5A,0x58,0x55,0x52,0x4F,0x4C,0x49,0x46,0x43,0x41,0x3E,0x3B,0x39,0x36,0x34,0x31,0x2F,0x2C,0x2A,0x28,
		0x25,0x23,0x21,0x1F,0x1D,0x1B,0x19,0x17,0x15,0x14,0x12,0x11,0x0F,0x0E,0x0C,0x0B,0x0A,0x09,0x07,0x06,0x05,0x05,0x04,0x03,0x02,0x02,0x01,0x01,0x01,0x00,0x00,0x00,
		0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x02,0x02,0x03,0x04,0x05,0x05,0x06,0x07,0x09,0x0A,0x0B,0x0C,0x0E,0x0F,0x11,0x12,0x14,0x15,0x17,0x19,0x1B,0x1D,0x1F,0x21,0x23,
		0x25,0x28,0x2A,0x2C,0x2F,0x31,0x34,0x36,0x39,0x3B,0x3E,0x41,0x43,0x46,0x49,0x4C,0x4F,0x52,0x55,0x58,0x5A,0x5D,0x61,0x64,0x67,0x6A,0x6D,0x70,0x73,0x76,0x79,0x7C,
};*/
unsigned char vga_active=0;
unsigned char chang_ram_active=0;
unsigned char WaveUp_active=0;
unsigned char WaveDown_active=0;
unsigned char WaveLeft=0;
unsigned char WaveRight=0;
unsigned char WaveLeftRight_Steps=0;
 char WaveUpDown_Steps=0;
unsigned char FrequencyUp=0;
unsigned char FrequencyDown=0;
unsigned char Frequency_Steps=1;
unsigned char WaveVppUp=0;
unsigned char WaveVppDown=0;
unsigned char WaveTabLoad_Finish=0;
float WaveVppUpDown_Steps=0;
unsigned char KeyFlag=0;
unsigned char lock=0;
int ADC_DataMax=0;
int ADC_DataMin=0;
float WaveTab[1024];
float WaveTab2[1024];
float WaveTab3[1024];
int x_dis=0;
XGpio button;
static XIntc InterruptController;
volatile  static int InterruptFlag=0;
void DevicedDiverHander(void *CallbackRef);
static XSysMon SysMonInst;
static int SysMonFractionToInt(float FloatNum);
void DevicedDiverHander(void *CallbackRef);//中断服务
void print(const char8 *ptr);
void WaveUpDown_Scan();
void FrequencyUpDown_Scan();
void WaveVppUpDown_Scan();
//void print(char*str)
int main()
{
	int i=0,j=0,k=0;
	u8 SeqMode;
	u32 TempRawData,VccIntRawData,ExtVolRawData,AUXRawData0,AUXRawData1,AUXRawData2;
	float TempData,VccIntData,ExtVolData,AUXRawData;
	int xStatus;
	XSysMon_Config *SysMonConfigPtr;
	XSysMon*SysMonInstPtr = &SysMonInst;
	{

		XGpio_Initialize(&button,XPAR_BUTTON_DEVICE_ID);//button GPIO³õÊ¼»¯
		XGpio_InterruptEnable(&button,XGPIO_IR_CH1_MASK);//Ê¹ÄÜGPIO¿ÚÖÐ¶Ï,µÚ¶þ¸ö±äÁ¿Î»ÓÚxgpio_i.hÎÄ¼þ
		XGpio_InterruptGlobalEnable(&button);//ÖÐ¶ÏÈ«Ê¹ÄÜ
		XIntc_Initialize (&InterruptController, XPAR_INTC_0_DEVICE_ID/*ÖÐ¶ÏÔ´ID*/);//#define XPAR_INTC_0_DEVICE_ID XPAR_MICROBLAZE_0_AXI_INTC_DEVICE_ID
		{
		 	XIntc_Connect (&InterruptController, XPAR_MICROBLAZE_0_AXI_INTC_BUTTON_IP2INTC_IRPT_INTR/*maskÏÂÃæ*/, (XInterruptHandler)DevicedDiverHander/*ÖÐ¶Ï·þÎñ³ÌÐò*/, (void *)0);
		 	XIntc_Start (&InterruptController,XIN_REAL_MODE/*Ó²¼þÖÐ¶ÏÄ£Ê½*/);
		 	XIntc_Enable (&InterruptController, XPAR_MICROBLAZE_0_AXI_INTC_BUTTON_IP2INTC_IRPT_INTR);
			Xil_ExceptionInit();

			/*
			 * Register the interrupt controller handler with the exception table.
			 */
			Xil_ExceptionRegisterHandler(XIL_EXCEPTION_ID_INT,
							(Xil_ExceptionHandler)XIntc_InterruptHandler,
							&InterruptController);

				/*
				 * Enable exceptions.
				 */
			Xil_ExceptionEnable();

		}
	}
	//{
		init_platform();
		//xil_printf("Hello World\n\r");
		SysMonConfigPtr = XSysMon_LookupConfig(SYSMON_DEVICE_ID);
		if(SysMonConfigPtr == NULL) xil_printf ("LookupConfig FAILURE\n\r");
		xStatus = XSysMon_CfgInitialize(SysMonInstPtr,SysMonConfigPtr,SysMonConfigPtr->BaseAddress);
		if(XST_SUCCESS!= xStatus)xil_printf("CfgInitialize FAILED\r\n");
		XSysMon_GetStatus(SysMonInstPtr);
	//}
while(1)
{
	while((XSysMon_GetStatus(SysMonInstPtr)&XSM_SR_EOS_MASK)!=XSM_SR_EOS_MASK);
	//TempRawData = XSysMon_GetAdcData(SysMonInstPtr,XSM_CH_TEMP);
	//TempData = XSysMon_RawToTemperature(TempRawData);
	//VccIntRawData = XSysMon_GetAdcData(SysMonInstPtr,XSM_CH_VCCINT);
	//VccIntData = XSysMon_RawToVoltage(VccIntRawData)*10;
	//ExtVolRawData = XSysMon_GetAdcData(SysMonInstPtr,XSM_CH_VPVN);
	//ExtVolData = XSysMon_RawToExtVoltage(ExtVolRawData)*100;
	//xil_printf("\r\n%0d.%03d, %0d.%03d, %0d.%03d", (int)(ExtVolRawData),(int)(ExtVolData),SysMonFractionToInt (ExtVolData));
	//xil_printf("\r\n%d, %d, %d", (int)(chang_ram_active),(int)(WaveTab2[i]),(int)(WaveTab[i]));
	AUXRawData0 = XSysMon_GetAdcData(SysMonInstPtr,XSM_CH_AUX_MIN);
		//AUXRawData1 = XSysMon_GetAdcData(SysMonInstPtr,0x11);
		//xil_printf("\r\n%d", (int)(AUXRawData1));
		//AUXRawData2 = XSysMon_GetAdcData(SysMonInstPtr,0x18);
		AUXRawData = (((float)(AUXRawData0))*(256.0f))/65536.0f;
	    WaveUpDown_Scan();
	    FrequencyUpDown_Scan();
	    WaveVppUpDown_Scan();

	    /*WaveTab[1023]=AUXRawData;
		for(i = 0 ; i < 1023 ; i++)
		{
			WaveTab[i] = WaveTab[i+1];
		}*/
	    if(i<1023)
		{
			WaveTabLoad_Finish=0;
			i++;

		}
		else
		{
			WaveTabLoad_Finish=1;
			i=0;
			//chang_ram_active=!chang_ram_active;

		}
		//if(chang_ram_active)
		{

				//if(!lock)
				{
			//if(fabs(WaveTab[i-1]-AUXRawData)<10)
					WaveTab[i]=AUXRawData;
					//WaveTabLoad_Finish=1;

				}


		}



		//else
		{
			//if(fabs(WaveTab[i-1]-AUXRawData)<20)
			//WaveTab2[i]=AUXRawData;

		}
		if(WaveTabLoad_Finish&&(!lock))
		{

				for(j=0;j<799;j++)
				{
					if(k<799)
					{
						k=k+Frequency_Steps;
					}
					else
						k=0;

					//if(chang_ram_active)
					{
						Xil_Out32((VGA),j);
						Xil_Out32((VGA+4),(((WaveTab[k+WaveLeftRight_Steps])-0x80)/(1+WaveVppUpDown_Steps)+300+(float)(0x80*600/65536)-WaveUpDown_Steps));
						//xil_printf("WaveTab[i]=%d\n\r",(((WaveTab[j+WaveLeftRight_Steps])-0x80)/(1+WaveVppUpDown_Steps)+240-WaveUpDown_Steps));
					}
					//else
					{
						//Xil_Out32((VGA),j);
						//Xil_Out32((VGA+4),(((WaveTab2[k+WaveLeftRight_Steps])-0x80)/(1+WaveVppUpDown_Steps)+360-WaveUpDown_Steps));
					}
				}
		}
}

return 0;
}
int SysMonFractionToInt(float FloatNum)
{
float Temp;
Temp = FloatNum;
if (FloatNum < 0) {
Temp = -(FloatNum);
}
return( ((int)((Temp -(float)((int)Temp)) * (1000.0f))));
}

int data=0;
void DevicedDiverHander(void *CallbackRef)//GPIOÖÐ¶Ï·þÎñº¯Êý
{
	//xil_printf("intc_success");
	if(XGpio_DiscreteRead(&button,1)==4)//
	{
			KeyFlag=!KeyFlag;
	}
	if(!KeyFlag)
	{
		if(XGpio_DiscreteRead(&button,1)==16)//
		{
			WaveUp_active=1;
		}
		else if(XGpio_DiscreteRead(&button,1)==2)
		{
			WaveDown_active=1;
		}
		else if(XGpio_DiscreteRead(&button,1)==8)
		{
			lock=!lock;
		}
		else if(XGpio_DiscreteRead(&button,1)==1)
		{
			WaveRight=1;
		}
	}
	else
	{
		if(XGpio_DiscreteRead(&button,1)==16)//
		{
			WaveVppUp=1;
		}
		else if(XGpio_DiscreteRead(&button,1)==2)
		{
			WaveVppDown=1;
		}
		else if(XGpio_DiscreteRead(&button,1)==8)
		{
			FrequencyDown=1;
		}
		else if(XGpio_DiscreteRead(&button,1)==1)
		{
			FrequencyUp=1;
		}
	}

	XGpio_InterruptClear(&button,XGPIO_IR_CH1_MASK);

}
void WaveUpDown_Scan()
{
	if(WaveUp_active==1)
	{
		WaveUp_active=0;
		//xil_printf("WaveUp\n\r");
		WaveUpDown_Steps+=5;
	}
	else if(WaveDown_active==1)
	{
		WaveDown_active=0;
		//xil_printf("WaveDown\n\r");
		//if(WaveUpDown_Steps>=5)
			WaveUpDown_Steps-=5;
	}
}
void FrequencyUpDown_Scan()
{
	if(FrequencyUp)
	{
		FrequencyUp=0;
		Frequency_Steps++;
		//xil_printf("Frequency_Steps=%d\n\r",Frequency_Steps);
	}
	else if(FrequencyDown)
	{
		FrequencyDown=0;
		if(Frequency_Steps>1)
		{
			Frequency_Steps--;
			//xil_printf("Frequency_Steps=%d\n\r",Frequency_Steps);
		}
	}

}

void WaveVppUpDown_Scan()
{
	if(WaveVppUp)
	{
		WaveVppUp=0;
		if(WaveVppUpDown_Steps>=0.2)
			WaveVppUpDown_Steps=WaveVppUpDown_Steps-0.2;
		//xil_printf("WaveVppUpDown_Steps=%f\n\r",WaveVppUpDown_Steps);
	}
	else if(WaveVppDown)
	{
		WaveVppDown=0;
		//xil_printf("WaveVppDown\n\r");
		WaveVppUpDown_Steps=WaveVppUpDown_Steps+0.2;
		//xil_printf("WaveVppUpDown_Steps=%f\n\r",WaveVppUpDown_Steps);
	}
}
